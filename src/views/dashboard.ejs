<%- include('partials/header', { title: 'Dashboard' }) %>
  <section class="grid two">
    <div class="panel">
      <div class="panel-header">
        <div>
          <h2>Calorie balance</h2>
        </div>
      </div>
      <div class="stats">
        <div class="stat">
          <div class="stat-label">Daily goal</div>
          <div class="stat-value" data-stat-goal><%= user.daily_goal ? `${user.daily_goal} kcal` : 'Not set' %></div>
        </div>
        <div class="stat stat-balance <%= !user.daily_goal ? '' : goalStatus === 'under' ? 'stat-success' : goalStatus === 'over_threshold' ? 'stat-danger' : 'stat-warning' %>" data-stat-balance>
          <div class="stat-label">Balance</div>
          <div class="stat-value" data-stat-logged><%= todayTotal %> kcal</div>
          <div class="stat-detail muted small" data-stat-status-detail>
            <% if (!user.daily_goal) { %>
              Set a goal to track
            <% } else if (goalStatus === 'under') { %>
              <%= goalDelta %> kcal remaining
            <% } else { %>
              <%= goalDelta %> kcal over
            <% } %>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="panel">
    <div class="panel-header">
      <div>
        <h2>Munch log</h2>
      </div>
      <div class="ai-photo-wrap">
        <% if (hasAiEnabled && aiUsage) { %>
          <span class="ai-usage-badge <%= aiUsage.remaining === 0 ? 'exhausted' : '' %>" title="<%= aiUsage.used %>/<%= aiUsage.limit %> today"><%= aiUsage.remaining %></span>
        <% } %>
        <button
          type="button"
          class="ai-photo-btn <%= !hasAiEnabled || (aiUsage && aiUsage.remaining === 0) ? 'disabled' : '' %>"
          data-ai-photo-trigger
          <% if (!hasAiEnabled) { %>title="AI not configured by server admin"<% } else { %>title="Estimate calories from photo"<% } %>
          <%= !hasAiEnabled || (aiUsage && aiUsage.remaining === 0) ? 'disabled' : '' %>>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
        </button>
      </div>
    </div>
    <form action="/entries" method="POST" class="stack horizontal" data-log-form>
      <label class="field">
        <span>Calories</span>
        <input
          type="text"
          inputmode="text"
          pattern="[0-9+\-*/().\s]*"
          name="amount"
          placeholder="e.g. 250 or -200"
          autocomplete="off"
          id="math-input"
          data-calorie-input
        >
      </label>
      <label class="field">
        <span>What</span>
        <input type="text" name="entry_name" maxlength="120" placeholder="Breakfast, snack...">
      </label>
      <label class="field">
        <span>Date</span>
        <input type="date" name="entry_date" data-date-input data-weight-date value="<%= selectedDate %>">
      </label>
      <button type="submit" class="primary" disabled data-submit-btn>Record</button>
    </form>
  </section>

  <section class="panel">
    <div class="panel-header">
      <div>
        <h2>Timeline</h2>
        <p class="muted small">Showing <%= range.start %> to <%= range.end %> 路 <%= range.days %> days</p>
      </div>
      <div class="timeframe">
        <div class="range-controls">
          <button type="button" class="ghost small range-toggle" data-range-toggle>More options</button>
          <form method="GET" class="range-custom <%= range.preset === null ? '' : 'hidden' %>" data-range-custom>
            <input type="hidden" name="day" value="<%= selectedDate %>">
            <div class="range-chips nested">
              <% [7, 14, 30, 60, 90, 120, 180].forEach((days) => { %>
                <button type="submit" name="range" value="<%= days %>" class="range-chip narrow <%= range.preset === days ? 'active' : '' %>"><%= days %>d</button>
              <% }) %>
            </div>
            <label class="field compact">
              <span>From</span>
              <input type="date" name="start" value="<%= range.start %>">
            </label>
            <label class="field compact">
              <span>To</span>
              <input type="date" name="end" value="<%= range.end %>">
            </label>
            <button class="ghost" type="submit">Apply</button>
          </form>
        </div>
      </div>
    </div>
    <div class="share-grid" data-share-grid data-range-start="<%= range.start %>" data-range-end="<%= range.end %>">
      <% sharedViews.forEach((view) => { %>
        <div
          class="share-card"
          data-share-block
          data-user-id="<%= view.userId %>"
          data-user-label="<%= view.label %>"
          data-user-email="<%= view.email %>"
          data-link-id="<%= view.linkId || '' %>"
          data-is-self="<%= view.isSelf %>"
          data-daily-goal="<%= view.dailyGoal || '' %>"
          data-today-str="<%= view.todayStr %>"
        >
          <div class="share-card-head">
            <div>
              <p class="eyebrow"><%= view.isSelf ? 'You' : 'Shared' %></p>
              <h3 class="share-title">
                <% if (view.isSelf) { %>
                  <%= view.label %>
                <% } else { %>
                  <button
                    type="button"
                    class="share-title-btn"
                    data-edit-share-label
                    data-link-id="<%= view.linkId %>"
                  ><%= view.label %></button>
                <% } %>
              </h3>
            </div>
            <div class="chip <%= view.dailyGoal ? '' : 'muted' %>">
              <%= view.dailyGoal ? `${view.dailyGoal} kcal goal` : 'Goal not set' %>
            </div>
          </div>
          <div class="dot-row">
            <% view.dailyStats.forEach((day) => { %>
              <div
                class="dot-wrap"
                role="button"
                tabindex="0"
                data-day-dot
                data-user-id="<%= view.userId %>"
                data-user-label="<%= view.label %>"
                data-link-id="<%= view.linkId || '' %>"
                data-is-self="<%= view.isSelf %>"
                data-date="<%= day.date %>"
                data-tip="<%= day.date %>"
                data-today-str="<%= view.todayStr %>"
              >
                <% if (!view.dailyGoal) { %>
                  <div class="dot muted <%= day.date === view.todayStr ? 'today' : '' %>"></div>
                <% } else if (day.status === 'zero') { %>
                  <div class="dot zero <%= day.date === view.todayStr ? 'today' : '' %>"></div>
                <% } else if (day.status === 'under') { %>
                  <div class="dot success <%= day.date === view.todayStr ? 'today' : '' %>"></div>
                <% } else if (day.status === 'over_threshold') { %>
                  <div class="dot danger <%= day.date === view.todayStr ? 'today' : '' %>"></div>
                <% } else { %>
                  <div class="dot warn <%= day.date === view.todayStr ? 'today' : '' %>"></div>
                <% } %>
              </div>
            <% }) %>
          </div>
        </div>
      <% }) %>
    </div>
    <div class="day-selected" data-day-selected>Showing <%= selectedDate === todayStr ? 'today' : selectedDate %> 路 You</div>
    <%
      const weightTime = weightEntry ? weightEntry.timeFormatted : '';
      const formatWeightValue = (kg) => {
        if (!kg) return '';
        return (weightUnit || 'kg').toLowerCase() === 'kg' ? `${kg} kg` : `${(kg * 2.20462).toFixed(1)} lb`;
      };
      const formatDaysAgo = (weightDateStr, selectedDateStr) => {
        if (!weightDateStr || !selectedDateStr) return null;
        const weightDate = new Date(weightDateStr + 'T00:00:00');
        const selected = new Date(selectedDateStr + 'T00:00:00');
        const diffDays = Math.round((selected - weightDate) / (1000 * 60 * 60 * 24));
        if (diffDays < 0) return null;
        if (diffDays === 0) return 'today';
        if (diffDays === 1) return '1d ago';
        return `${diffDays}d ago`;
      };
      const lastWeightIsValid = lastWeightEntry && formatDaysAgo(lastWeightEntry.date, selectedDate) !== null;
      const displayWeight = weightEntry || (lastWeightIsValid ? lastWeightEntry : null);
      const weightDisplayText = displayWeight ? formatWeightValue(displayWeight.weight) : 'No weight logged';
      const isLastWeight = !weightEntry && lastWeightIsValid;
      const lastWeightDaysAgo = isLastWeight ? formatDaysAgo(lastWeightEntry.date, selectedDate) : null;
    %>
    <div class="log-list">
      <div class="weight-slot" data-weight-slot>
        <div class="entry-row weight-row <%= weightEntry ? '' : 'is-empty' %>" data-weight-row>
          <div>
            <button type="button" class="edit-trigger entry-name is-locked" data-locked="true"><%= isLastWeight ? 'Last weight' : 'Weight' %></button>
          </div>
          <div class="entry-actions">
            <div class="entry-amount-wrap">
              <button type="button" class="edit-trigger entry-amount weight <%= displayWeight ? '' : 'muted' %>" data-weight-value><%= weightDisplayText %></button>
            </div>
            <span class="entry-time muted small" data-weight-time><%= weightEntry ? weightTime : (lastWeightDaysAgo || '') %></span>
            <% if (weightEntry && weightEntry.id) { %>
              <form action="/weight/<%= weightEntry.id %>/delete" method="POST" class="inline-form" data-weight-delete-form>
                <button type="submit" class="ghost danger small" data-delete-weight data-weight-id="<%= weightEntry.id %>">Delete</button>
              </form>
            <% } else { %>
              <form class="inline-form delete-placeholder" aria-hidden="true">
                <button type="button" class="ghost danger small placeholder-delete" tabindex="-1">Delete</button>
              </form>
            <% } %>
          </div>
        </div>
      </div>
      <div class="entry-list <%= (!recentEntries || recentEntries.length === 0) ? 'hidden' : '' %>" data-entry-list>
        <% if (recentEntries && recentEntries.length > 0) { %>
          <% recentEntries.forEach((entry) => { %>
            <div class="entry-row" data-entry-row data-entry-id="<%= entry.id %>">
              <div>
                <button type="button" class="edit-trigger entry-name" data-edit-name><%= entry.entry_name || 'Untitled' %></button>
              </div>
              <div class="entry-actions">
                <div class="entry-amount-wrap">
                  <button type="button" class="edit-trigger entry-amount <%= entry.amount >= 0 ? 'pos' : 'neg' %>" data-edit-amount><%= entry.amount %> kcal</button>
                </div>
                <span class="entry-time muted small" data-entry-time><%= entry.timeFormatted %></span>
                <form action="/entries/<%= entry.id %>/delete" method="POST" class="inline-form" data-delete-form>
                  <button type="submit" class="ghost danger small" data-delete-entry data-entry-id="<%= entry.id %>">Delete</button>
                </form>
              </div>
            </div>
          <% }) %>
        <% } %>
      </div>
      <div class="muted <%= (!recentEntries || recentEntries.length === 0) ? '' : 'hidden' %>" data-entry-empty>No entries yet.</div>
    </div>
  </section>

  <script>
    (() => {
      let dots = Array.from(document.querySelectorAll('[data-day-dot]'));
      const entryList = document.querySelector('[data-entry-list]');
      const emptyState = document.querySelector('[data-entry-empty]');
      const daySelected = document.querySelector('[data-day-selected]');
      const selfUserId = '<%= user.id %>';
      const clientTz = '<%= timeZone %>' || Intl.DateTimeFormat().resolvedOptions().timeZone;
      const todayStr = '<%= todayStr %>';
      const weightUnit = '<%= (weightUnit || "lb").toLowerCase() %>';
      let currentDate = '<%= selectedDate %>';
      let currentUserId = selfUserId;
      let currentLabel = <%- JSON.stringify(sharedViews && sharedViews.length ? sharedViews[0].label : 'You') %>;
      let currentCanEdit = true;
      let activeInlineEdit = null;
      let activeShareLabelEdit = null;
      let entryEventSource = null;
      let pollTimer = null;
      const initialEntries = <%- JSON.stringify(recentEntries.map((entry) => ({
        id: entry.id,
        date: entry.entry_date ? entry.entry_date.toISOString().slice(0, 10) : selectedDate,
        time: entry.timeFormatted || '',
        amount: entry.amount,
        name: entry.entry_name || null,
      }))) %>;
      const weightDateInput = document.querySelector('[data-weight-date]');
      const weightSlot = document.querySelector('[data-weight-slot]');
      const weightRow = document.querySelector('[data-weight-row]');
      const weightValueBtn = document.querySelector('[data-weight-value]');
      const weightTime = document.querySelector('[data-weight-time]');
      const rangeToggle = document.querySelector('[data-range-toggle]');
      const rangeCustom = document.querySelector('[data-range-custom]');
      const shareGrid = document.querySelector('[data-share-grid]');
      const rangeStart = shareGrid?.dataset.rangeStart || '';
      const rangeEnd = shareGrid?.dataset.rangeEnd || '';
      const statGoal = document.querySelector('[data-stat-goal]');
      const statLogged = document.querySelector('[data-stat-logged]');
      const statBalance = document.querySelector('[data-stat-balance]');
      const statStatusDetail = document.querySelector('[data-stat-status-detail]');
      const initialWeight = <%- JSON.stringify(weightEntry || null) %>;
      const lastWeight = <%- JSON.stringify(lastWeightEntry || null) %>;
      const weightCache = new Map();
      if (initialWeight) {
        weightCache.set(`${selfUserId}:${initialWeight.date}`, initialWeight);
      }

      const escapeHtml = (value) =>
        String(value || '').replace(
          /[&<>"']/g,
          (ch) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch])
        );

      const kgToLb = (kg) => Math.round((Number(kg) || 0) * 2.20462 * 10) / 10;
      const lbToKg = (lb) => {
        const num = parseFloat(lb);
        if (Number.isNaN(num) || num <= 0) return null;
        return Math.round((num / 2.20462) * 100) / 100;
      };

      const formatTime = (value) => {
        if (!value) return '';
        const dateObj = value instanceof Date ? value : new Date(value);
        if (Number.isNaN(dateObj.getTime())) return '';
        try {
          return new Intl.DateTimeFormat('en-GB', {
            timeZone: clientTz || undefined,
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
          }).format(dateObj);
        } catch (err) {
          return dateObj.toISOString().slice(11, 16);
        }
      };

      const formatDateTz = (value) => {
        const dateObj = value instanceof Date ? value : new Date(value);
        if (Number.isNaN(dateObj.getTime())) return '';
        try {
          const formatted = new Intl.DateTimeFormat('en-CA', {
            timeZone: clientTz || undefined,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
          }).format(dateObj);
          const parts = formatted.split('-');
          if (parts.length === 3) return `${parts[0]}-${parts[1]}-${parts[2]}`;
          return formatted;
        } catch (err) {
          return dateObj.toISOString().slice(0, 10);
        }
      };

      const saveShareLabel = async (linkId, label) => {
        const res = await fetch(`/links/${linkId}/label`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
          },
          body: JSON.stringify({ label }),
        });
        if (!res.ok) {
          throw new Error('Label request failed');
        }
        const data = await res.json();
        if (!data.ok) {
          throw new Error('Label save rejected');
        }
        return data.label || '';
      };

      const updateTopStats = (data) => {
        if (!data) return;
        if (statGoal) {
          statGoal.textContent = data.dailyGoal ? `${data.dailyGoal} kcal` : 'Not set';
        }
        if (statLogged) {
          statLogged.textContent = `${data.todayTotal || 0} kcal`;
        }
        if (statBalance) {
          statBalance.classList.remove('stat-success', 'stat-warning', 'stat-danger');
          if (data.dailyGoal) {
            if (data.goalStatus === 'under') {
              statBalance.classList.add('stat-success');
            } else if (data.goalStatus === 'over_threshold') {
              statBalance.classList.add('stat-danger');
            } else {
              statBalance.classList.add('stat-warning');
            }
          }
        }
        if (statStatusDetail) {
          if (!data.dailyGoal) {
            statStatusDetail.textContent = 'Set a goal to track';
          } else if (data.goalStatus === 'under') {
            statStatusDetail.textContent = `${Math.abs(data.goalDelta || 0)} kcal remaining`;
          } else {
            statStatusDetail.textContent = `${Math.abs(data.goalDelta || 0)} kcal over`;
          }
        }
      };

      const renderShareCardMeta = (card, data) => {
        if (!card || !data) return;
        const chip = card.querySelector('.chip');
        if (chip) {
          chip.textContent = data.dailyGoal ? `${data.dailyGoal} kcal goal` : 'Goal not set';
          chip.classList.toggle('muted', !data.dailyGoal);
        }
      };

      const dotHtmlForDay = (day, view) => {
        const todayMark = day.date === view.todayStr ? 'today' : '';
        const base = 'dot';
        let variant = 'muted';
        if (view.dailyGoal) {
          if (day.status === 'zero') {
            variant = 'zero';
          } else if (day.status === 'under') {
            variant = 'success';
          } else if (day.status === 'over_threshold') {
            variant = 'danger';
          } else {
            variant = 'warn';
          }
        }
        return `
          <div
            class="dot-wrap"
            role="button"
            tabindex="0"
            data-day-dot
            data-user-id="${view.userId}"
            data-user-label="${escapeHtml(view.label)}"
            data-link-id="${view.linkId || ''}"
            data-is-self="${view.isSelf}"
            data-date="${day.date}"
            data-tip="${day.date}"
          >
            <div class="${base} ${variant} ${todayMark}"></div>
          </div>
        `;
      };

      const renderCardDots = (card, dailyStats, todayStr) => {
        if (!card) return;
        const row = card.querySelector('.dot-row');
        if (!row || !Array.isArray(dailyStats)) return;
        const viewMeta = {
          userId: card.dataset.userId,
          label: card.dataset.userLabel || card.dataset.userEmail || 'Shared',
          linkId: card.dataset.linkId || '',
          isSelf: card.dataset.isSelf === 'true',
          dailyGoal: card.dataset.dailyGoal ? Number(card.dataset.dailyGoal) : null,
          todayStr,
        };
        row.innerHTML = dailyStats.map((day) => dotHtmlForDay(day, viewMeta)).join('');
      };

      const teardownShareLabelEditor = () => {
        if (activeShareLabelEdit) {
          const { form, trigger, card } = activeShareLabelEdit;
          form.remove();
          trigger.classList.remove('hidden');
          card.classList.remove('is-editing');
          activeShareLabelEdit = null;
        }
      };

      const openShareLabelEditor = (btn) => {
        const shareCard = btn.closest('[data-share-block]');
        const linkId = btn.dataset.linkId;
        if (!shareCard || !linkId) return;
        if (shareCard.querySelector('[data-inline-editing]')) return;

        if (activeInlineEdit) {
          const { form, btn: openBtn } = activeInlineEdit;
          form.remove();
          openBtn.classList.remove('hidden');
          activeInlineEdit = null;
        }
        teardownShareLabelEditor();
        teardownWeightEditor();

        const form = document.createElement('form');
        form.className = 'inline-edit';
        form.dataset.inlineEditing = 'true';

        const input = document.createElement('input');
        input.type = 'text';
        input.autocomplete = 'off';
        input.maxLength = 120;
        input.className = 'inline-edit-input';
        input.placeholder = shareCard.dataset.userEmail || 'Label';
        input.value = btn.textContent.trim();

        const spinner = document.createElement('span');
        spinner.className = 'inline-edit-spinner hidden';

        form.append(input, spinner);
        btn.insertAdjacentElement('afterend', form);
        btn.classList.add('hidden');
        shareCard.classList.add('is-editing');

        const finish = () => {
          form.remove();
          btn.classList.remove('hidden');
          shareCard.classList.remove('is-editing');
          if (activeShareLabelEdit && activeShareLabelEdit.form === form) {
            activeShareLabelEdit = null;
          }
        };

        let saving = false;
        const handleSave = async () => {
          if (saving) return;
          saving = true;
          form.classList.add('is-saving');
          spinner.classList.remove('hidden');
          try {
            const updatedLabel = input.value.trim();
            const saved = await saveShareLabel(linkId, updatedLabel);
            applyShareLabel(shareCard, saved);
            finish();
          } catch (err) {
            console.error('Failed to save label', err);
            saving = false;
            form.classList.remove('is-saving');
            spinner.classList.add('hidden');
          }
        };

        form.addEventListener('submit', (evt) => {
          evt.preventDefault();
          handleSave();
        });

        input.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape') {
            finish();
          } else if (evt.key === 'Enter') {
            evt.preventDefault();
            handleSave();
          }
        });

        input.addEventListener('blur', handleSave);

        activeShareLabelEdit = { form, trigger: btn, card: shareCard };
        input.focus();
        input.select();
      };

      if (rangeToggle && rangeCustom) {
        rangeToggle.addEventListener('click', () => {
          const showing = rangeCustom.classList.toggle('hidden') === false;
          rangeToggle.textContent = showing ? 'Hide options' : 'More options';
        });
      }

      const renderEntries = (entries, canEdit) => {
        if (!entryList) return;
        entryList.innerHTML = '';
        if (!entries || entries.length === 0) {
          entryList.classList.add('hidden');
          if (emptyState) {
            emptyState.textContent = canEdit ? 'No entries yet.' : 'No shared entries yet.';
            emptyState.classList.remove('hidden');
          }
          return;
        }

        if (emptyState) emptyState.classList.add('hidden');
        entryList.classList.remove('hidden');
        entryList.innerHTML = entries
          .map((entry) => {
            const safeName = escapeHtml(entry.name || 'Untitled');
            if (!canEdit) {
              return `
              <div class="entry-row view-only" data-entry-row data-entry-id="${entry.id}">
                <div>
                  <button type="button" class="edit-trigger entry-name is-locked" data-locked="true">${safeName}</button>
                </div>
                <div class="entry-actions">
                  <div class="entry-amount-wrap">
                    <button type="button" class="edit-trigger entry-amount ${entry.amount >= 0 ? 'pos' : 'neg'} is-locked" data-locked="true">${entry.amount} kcal</button>
                  </div>
                  <span class="entry-time muted small">${entry.time || ''}</span>
                  <form class="inline-form delete-placeholder" aria-hidden="true">
                    <button type="button" class="ghost danger small placeholder-delete" tabindex="-1">Delete</button>
                  </form>
                </div>
              </div>
            `;
            }
            return `
            <div class="entry-row" data-entry-row data-entry-id="${entry.id}">
              <div>
                <button type="button" class="edit-trigger entry-name" data-edit-name>${safeName}</button>
              </div>
              <div class="entry-actions">
                <div class="entry-amount-wrap">
                  <button type="button" class="edit-trigger entry-amount ${entry.amount >= 0 ? 'pos' : 'neg'}" data-edit-amount>${entry.amount} kcal</button>
                </div>
                <span class="entry-time muted small" data-entry-time>${entry.time || ''}</span>
                <form action="/entries/${entry.id}/delete" method="POST" class="inline-form" data-delete-form>
                  <button type="submit" class="ghost danger small" data-delete-entry data-entry-id="${entry.id}">Delete</button>
                </form>
              </div>
            </div>
          `;
          })
          .join('');
      };

      const formatDaysAgo = (weightDateStr, selectedDateStr) => {
        if (!weightDateStr || !selectedDateStr) return null;
        const weightDate = new Date(weightDateStr + 'T00:00:00');
        const selectedDate = new Date(selectedDateStr + 'T00:00:00');
        const diffDays = Math.round((selectedDate - weightDate) / (1000 * 60 * 60 * 24));
        if (diffDays < 0) return null;
        if (diffDays === 0) return 'today';
        if (diffDays === 1) return '1d ago';
        return `${diffDays}d ago`;
      };

      const lastWeightCache = new Map();
      if (lastWeight) {
        lastWeightCache.set(selfUserId, lastWeight);
      }

      const renderWeight = (entry, date, userId, label, canEdit, userLastWeight) => {
        if (weightDateInput) {
          weightDateInput.value = date;
        }
        if (weightRow && weightValueBtn) {
          const formatWeight = (kg) => {
            if (!kg) return '';
            return weightUnit === 'kg' ? `${kg} kg` : `${kgToLb(kg)} lb`;
          };
          const labelBtn = weightRow.querySelector('.entry-name');
          const lastWeightDaysAgo = userLastWeight ? formatDaysAgo(userLastWeight.date, date) : null;
          const lastWeightIsValid = lastWeightDaysAgo !== null;
          const displayEntry = entry || (lastWeightIsValid ? userLastWeight : null);
          const isLastWeight = !entry && lastWeightIsValid;
          if (labelBtn) {
            labelBtn.textContent = isLastWeight ? 'Last weight' : 'Weight';
            labelBtn.dataset.locked = 'true';
            labelBtn.classList.add('is-locked');
          }
          const timeStr =
            entry && (entry.updated_at || entry.created_at)
              ? formatTime(entry.updated_at || entry.created_at)
              : '';
          weightRow.classList.toggle('is-empty', !entry);
          weightValueBtn.textContent = displayEntry ? formatWeight(displayEntry.weight) : 'No weight logged';
          weightValueBtn.classList.toggle('muted', !displayEntry);
          weightValueBtn.classList.toggle('pos', Boolean(entry));
          weightRow.classList.toggle('view-only', !canEdit);
          weightValueBtn.dataset.locked = String(!canEdit);
          weightValueBtn.classList.toggle('is-locked', !canEdit);
          if (weightTime) {
            weightTime.textContent = entry ? timeStr : (lastWeightDaysAgo || '');
          }
          // Update delete button
          const existingDeleteForm = weightRow.querySelector('[data-weight-delete-form]');
          const existingPlaceholder = weightRow.querySelector('.delete-placeholder');
          if (entry && entry.id && canEdit) {
            // Show real delete form
            if (existingPlaceholder) existingPlaceholder.remove();
            if (!existingDeleteForm) {
              const form = document.createElement('form');
              form.action = `/weight/${entry.id}/delete`;
              form.method = 'POST';
              form.className = 'inline-form';
              form.dataset.weightDeleteForm = 'true';
              form.innerHTML = `<button type="submit" class="ghost danger small" data-delete-weight data-weight-id="${entry.id}">Delete</button>`;
              weightRow.querySelector('.entry-actions').appendChild(form);
            } else {
              existingDeleteForm.action = `/weight/${entry.id}/delete`;
              const btn = existingDeleteForm.querySelector('[data-delete-weight]');
              if (btn) btn.dataset.weightId = entry.id;
            }
          } else {
            // Show placeholder or hide
            if (existingDeleteForm) existingDeleteForm.remove();
            if (!existingPlaceholder) {
              const placeholder = document.createElement('form');
              placeholder.className = 'inline-form delete-placeholder';
              placeholder.setAttribute('aria-hidden', 'true');
              placeholder.innerHTML = `<button type="button" class="ghost danger small placeholder-delete" tabindex="-1">Delete</button>`;
              weightRow.querySelector('.entry-actions').appendChild(placeholder);
            }
          }
        }
      };

      const applyShareLabel = (shareCard, rawLabel) => {
        if (!shareCard) return;
        const fallback = shareCard.dataset.userEmail || 'Shared';
        const displayLabel = rawLabel && rawLabel.trim() ? rawLabel.trim() : fallback;
        shareCard.dataset.userLabel = displayLabel;
        const dotsInCard = shareCard.querySelectorAll('[data-day-dot]');
        dotsInCard.forEach((dot) => {
          dot.dataset.userLabel = displayLabel;
        });
        const titleBtn = shareCard.querySelector('[data-edit-share-label]');
        const titleEl = shareCard.querySelector('.share-title');
        if (titleBtn) {
          titleBtn.textContent = displayLabel;
        } else if (titleEl) {
          titleEl.textContent = displayLabel;
        }
        if (String(currentUserId) === String(shareCard.dataset.userId)) {
          currentLabel = displayLabel;
          const labelDate = currentDate === todayStr ? 'today' : currentDate;
          if (daySelected) {
            daySelected.textContent = `Showing ${labelDate} 路 ${currentLabel}`;
          }
          const weightCacheKey = `${currentUserId}:${currentDate}`;
          renderWeight(
            weightCache.get(weightCacheKey) || null,
            currentDate,
            currentUserId,
            currentLabel,
            currentCanEdit
          );
        }
      };

      const fetchUserStats = async (userId) => {
        const params = new URLSearchParams();
        if (String(userId) !== String(selfUserId)) {
          params.set('user', userId);
        }
        if (rangeStart) params.set('start', rangeStart);
        if (rangeEnd) params.set('end', rangeEnd);
        try {
          const res = await fetch(`/overview?${params.toString()}`, { headers: { Accept: 'application/json' } });
          if (!res.ok) return null;
          const data = await res.json();
          if (!data.ok) return null;
          return data;
        } catch (err) {
          console.error('Failed to fetch stats', err);
          return null;
        }
      };

      const refreshCardForUser = async (userId) => {
        const card = document.querySelector(`[data-share-block][data-user-id="${userId}"]`);
        if (!card) return;
        const stats = await fetchUserStats(userId);
        if (!stats) return;
        card.dataset.dailyGoal = stats.dailyGoal || '';
        renderShareCardMeta(card, stats);
        renderCardDots(card, stats.dailyStats, stats.todayStr);
        attachDotHandlers();
        if (String(userId) === String(currentUserId)) {
          if (!stats.dayOptions.includes(currentDate)) {
            currentDate = stats.dayOptions[0];
          }
          setActiveDay(currentUserId, currentDate, currentLabel, currentCanEdit, stats.todayStr);
        }
        if (String(userId) === String(selfUserId)) {
          updateTopStats(stats);
        }
      };

      const loadWeightForDate = async (userId, date, label, canEdit) => {
        if (!weightDateInput || !date) return;
        const cacheKey = `${userId}:${date}`;
        if (weightCache.has(cacheKey)) {
          const userLastWeight = lastWeightCache.get(userId) || null;
          renderWeight(weightCache.get(cacheKey), date, userId, label, canEdit, userLastWeight);
          return;
        }
        try {
          const params = new URLSearchParams({ date });
          if (String(userId) !== String(selfUserId)) {
            params.set('user', userId);
          }
          const res = await fetch(`/weight/day?${params.toString()}`, { headers: { Accept: 'application/json' } });
          if (!res.ok) {
            renderWeight(null, date, userId, label, canEdit, null);
            return;
          }
          const data = await res.json();
          if (data.ok) {
            const entry = data.entry || null;
            const userLastWeight = data.lastWeight || null;
            weightCache.set(cacheKey, entry);
            if (userLastWeight) {
              lastWeightCache.set(userId, userLastWeight);
            }
            renderWeight(entry, date, userId, label, canEdit, userLastWeight);
          }
        } catch (err) {
          renderWeight(null, date, userId, label, canEdit, null);
        }
      };

      let activeWeightEdit = null;
      const teardownWeightEditor = () => {
        if (activeWeightEdit) {
          const { form, trigger } = activeWeightEdit;
          form.remove();
          if (trigger) trigger.classList.remove('hidden');
          activeWeightEdit = null;
        }
      };

      const saveWeight = async (value) => {
        const payload = { weight: value, entry_date: currentDate };
        const res = await fetch('/weight/upsert', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          throw new Error('Request failed');
        }
        const data = await res.json();
        if (!data.ok || !data.entry) {
          throw new Error('Save failed');
        }
        weightCache.set(`${selfUserId}:${data.entry.date}`, data.entry);
        const userLastWeight = lastWeightCache.get(selfUserId) || null;
        renderWeight(data.entry, data.entry.date, selfUserId, currentLabel, true, userLastWeight);
      };

      const openWeightEditor = (triggerEl) => {
        if (!weightSlot) return;
        const row = triggerEl?.closest('[data-weight-row]') || weightRow;
        if (!row) return;
        if (row.querySelector('[data-inline-editing]')) return;

        // Close any other inline edit (entries or weight) for consistency
        if (activeInlineEdit) {
          const { form, btn: openBtn } = activeInlineEdit;
          form.remove();
          if (openBtn) openBtn.classList.remove('hidden');
          activeInlineEdit = null;
        }

        const btnTarget = triggerEl || weightValueBtn;
        if (!btnTarget) return;
        if (!currentCanEdit) return;
        const form = document.createElement('form');
        form.className = 'inline-edit inline-edit--amount';
        form.dataset.inlineEditing = 'true';

        const input = document.createElement('input');
        input.type = 'tel';
        input.inputMode = 'tel';
        input.autocomplete = 'off';
        input.className = 'inline-edit-input inline-edit-input--amount';
        input.placeholder = weightUnit === 'kg' ? 'e.g. 72.4' : 'e.g. 180';
        const currentWeight = weightCache.get(`${selfUserId}:${currentDate}`)?.weight;
        input.value = currentWeight ? (weightUnit === 'kg' ? currentWeight : kgToLb(currentWeight)) : '';

        const spinner = document.createElement('span');
        spinner.className = 'inline-edit-spinner hidden';

        form.append(input, spinner);
        btnTarget.insertAdjacentElement('afterend', form);

        const finish = () => {
          form.remove();
          btnTarget.classList.remove('hidden');
          row.classList.remove('is-editing');
          activeInlineEdit = null;
          activeWeightEdit = null;
        };

        let saving = false;
        const handleSave = async () => {
          if (saving) return;
          const value = input.value.trim();
          if (!value) {
            finish();
            return;
          }
          saving = true;
          spinner.classList.remove('hidden');
          form.classList.add('is-saving');
          row.classList.add('is-editing');
          try {
            const kgVal = weightUnit === 'kg' ? parseFloat(value) : lbToKg(value);
            if (!kgVal) {
              finish();
              return;
            }
            await saveWeight(kgVal);
            finish();
          } catch (err) {
            console.error('Weight save failed', err);
            saving = false;
            spinner.classList.add('hidden');
            form.classList.remove('is-saving');
            row.classList.remove('is-editing');
          }
        };

        form.addEventListener('submit', (evt) => {
          evt.preventDefault();
          handleSave();
        });

        input.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape') {
            finish();
          } else if (evt.key === 'Enter') {
            evt.preventDefault();
            handleSave();
          }
        });

        input.addEventListener('blur', handleSave);

        btnTarget.classList.add('hidden');
        activeInlineEdit = { form, btn: btnTarget };
        activeWeightEdit = { form, trigger: btnTarget };
        input.focus();
        input.select();
      };

      const setActiveDay = (userId, date, label, isSelf, viewTodayStr) => {
        teardownWeightEditor();
        dots.forEach((dot) => {
          const active = dot.dataset.userId === String(userId) && dot.dataset.date === date;
          dot.classList.toggle('active', active);
        });
        if (daySelected) {
          // Only show "today" for self, show date for linked users
          const effectiveToday = viewTodayStr || todayStr;
          const labelDate = isSelf && date === effectiveToday ? 'today' : date;
          daySelected.textContent = `Showing ${labelDate} 路 ${label}`;
        }
        if (weightDateInput) {
          weightDateInput.value = date;
        }
        loadWeightForDate(userId, date, label, userId === selfUserId);
      };

      const attachDotHandlers = () => {
        dots = Array.from(document.querySelectorAll('[data-day-dot]'));
        dots.forEach((dot) => {
          const handle = () => {
            const date = dot.dataset.date;
            const userId = dot.dataset.userId;
            const viewTodayStr = dot.dataset.todayStr;
            if (!date || !userId) return;
            currentDate = date;
            currentUserId = userId;
            currentLabel = dot.dataset.userLabel || 'Shared';
            currentCanEdit = dot.dataset.isSelf === 'true';
            setActiveDay(userId, date, currentLabel, currentCanEdit, viewTodayStr);
            loadEntries(userId, date, currentCanEdit);
          };
          dot.onclick = handle;
          dot.onkeypress = (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              handle();
            }
          };
        });
      };

      const loadEntries = async (userId, date, canEdit) => {
        const params = new URLSearchParams({ date });
        if (String(userId) !== String(selfUserId)) {
          params.set('user', userId);
        }
        try {
          const res = await fetch(`/entries/day?${params.toString()}`, {
            headers: { Accept: 'application/json' },
          });
          if (!res.ok) return;
          const data = await res.json();
          if (data.ok) {
            const normalized = (data.entries || []).map((entry) => ({
              ...entry,
              time: entry.time || formatTime(entry.created_at),
            }));
            renderEntries(normalized, canEdit);
          }
        } catch (err) {
          console.error('Failed to load entries', err);
        }
      };

      const refreshCurrentEntries = () => {
        loadEntries(currentUserId, currentDate, currentCanEdit);
      };

      const stopPolling = () => {
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      };

      const startPolling = () => {
        if (pollTimer) return;
        pollTimer = setInterval(refreshCurrentEntries, 15000);
      };

      const handleEntryEvent = (payload) => {
        if (!payload || payload.sourceUserId === undefined) return;
        refreshCardForUser(String(payload.sourceUserId));
        if (String(payload.sourceUserId) === String(currentUserId)) {
          refreshCurrentEntries();
        }
      };

      const handleLinkLabelEvent = (payload) => {
        if (!payload || !payload.linkId) return;
        const card = document.querySelector(`[data-share-block][data-link-id="${payload.linkId}"]`);
        if (!card) return;
        applyShareLabel(card, payload.label || '');
      };

      const startEntryEvents = () => {
        if (!window.EventSource) {
          startPolling();
          return;
        }
        if (entryEventSource) return;
        const source = new EventSource('/events/entries');
        entryEventSource = source;
        source.addEventListener('entry-change', (evt) => {
          try {
            const data = JSON.parse(evt.data || '{}');
            handleEntryEvent(data);
          } catch (err) {
            console.error('Failed to parse entry event', err);
          }
        });
        source.addEventListener('link-label-change', (evt) => {
          try {
            const data = JSON.parse(evt.data || '{}');
            handleLinkLabelEvent(data);
          } catch (err) {
            console.error('Failed to parse label event', err);
          }
        });
        source.onerror = () => {
          source.close();
          entryEventSource = null;
          startPolling();
          setTimeout(startEntryEvents, 2000);
        };
      };

      document.addEventListener('submit', async (evt) => {
        if (!currentCanEdit) return;
        const form = evt.target.closest('[data-delete-form]');
        if (!form) return;
        evt.preventDefault();
        const btn = form.querySelector('[data-delete-entry]');
        const entryId = btn?.dataset.entryId;
        if (!entryId) return;
        try {
          const res = await fetch(`/entries/${entryId}/delete`, {
            method: 'POST',
            headers: { Accept: 'application/json' },
          });
          if (res.ok) {
            loadEntries(currentUserId, currentDate, currentCanEdit);
          }
        } catch (err) {
          console.error('Delete failed', err);
        }
      });

      document.addEventListener('submit', async (evt) => {
        if (!currentCanEdit) return;
        const form = evt.target.closest('[data-weight-delete-form]');
        if (!form) return;
        evt.preventDefault();
        const btn = form.querySelector('[data-delete-weight]');
        const weightId = btn?.dataset.weightId;
        if (!weightId) return;
        try {
          const res = await fetch(`/weight/${weightId}/delete`, {
            method: 'POST',
            headers: { Accept: 'application/json' },
          });
          if (res.ok) {
            weightCache.delete(`${selfUserId}:${currentDate}`);
            loadWeightForDate(currentUserId, currentDate, currentLabel, currentCanEdit);
          }
        } catch (err) {
          console.error('Weight delete failed', err);
        }
      });

      const updateEntry = async (entryId, payload) => {
        const res = await fetch(`/entries/${entryId}/update`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
          },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          throw new Error('Request failed');
        }
        const data = await res.json();
        if (!data.ok) {
          throw new Error('Update failed');
        }
        return data.entry;
      };

      const applyEntryUpdate = (row, entry) => {
        const nameBtn = row.querySelector('[data-edit-name]');
        const amountBtn = row.querySelector('[data-edit-amount]');
        const timeEl = row.querySelector('[data-entry-time]');
        if (nameBtn) {
          nameBtn.textContent = entry.name || 'Untitled';
        }
        if (amountBtn) {
          amountBtn.textContent = `${entry.amount} kcal`;
          amountBtn.classList.toggle('pos', entry.amount >= 0);
          amountBtn.classList.toggle('neg', entry.amount < 0);
        }
        if (timeEl && entry.time) {
          timeEl.textContent = entry.time;
        }
      };

      const createInlineEditor = ({ btn, type, placeholder }) => {
        const row = btn.closest('[data-entry-id]');
        const entryId = row?.dataset.entryId;
        if (!row || !entryId) return null;
        if (row.querySelector('[data-inline-editing]')) {
          return null;
        }
        if (activeInlineEdit) {
          const { form, btn: openBtn } = activeInlineEdit;
          form.remove();
          openBtn.classList.remove('hidden');
          activeInlineEdit = null;
        }

        const currentValue =
          type === 'amount'
            ? btn.textContent.replace('kcal', '').trim()
            : btn.textContent.trim() === 'Untitled'
            ? ''
            : btn.textContent.trim();

        btn.classList.add('hidden');

        const form = document.createElement('form');
        form.className = `inline-edit${type === 'amount' ? ' inline-edit--amount' : ''}`;
        form.dataset.inlineEditing = 'true';

        const input = document.createElement('input');
        input.type = 'text';
        if (type === 'amount') input.inputMode = 'text';
        input.autocomplete = 'off';
        input.className = `inline-edit-input${type === 'amount' ? ' inline-edit-input--amount' : ''}`;
        input.placeholder = placeholder;
        input.value = currentValue;

        const spinner = document.createElement('span');
        spinner.className = 'inline-edit-spinner hidden';

        form.append(input, spinner);

        const tearDown = () => {
          form.remove();
          btn.classList.remove('hidden');
          row.classList.remove('is-editing');
          if (activeInlineEdit && activeInlineEdit.form === form) {
            activeInlineEdit = null;
          }
          form.classList.remove('is-saving');
          spinner.classList.add('hidden');
        };

        let submitting = false;
        const handleSubmit = async () => {
          if (submitting) return;
          const value = input.value.trim();
          if (!value && type === 'amount') {
            tearDown();
            return;
          }
          submitting = true;
          form.classList.add('is-saving');
          spinner.classList.remove('hidden');
          row.classList.add('is-editing');
          try {
            const updated = await updateEntry(entryId, type === 'amount' ? { amount: value } : { name: value });
            applyEntryUpdate(row, updated);
            tearDown();
          } catch (err) {
            console.error('Update failed', err);
            submitting = false;
            form.classList.remove('is-saving');
            spinner.classList.add('hidden');
          }
        };

        form.addEventListener('submit', (evt) => {
          evt.preventDefault();
          handleSubmit();
        });

        input.addEventListener('keydown', (evt) => {
          if (evt.key === 'Escape') {
            tearDown();
          } else if (evt.key === 'Enter') {
            evt.preventDefault();
            handleSubmit();
          }
        });

        input.addEventListener('blur', () => {
          handleSubmit();
        });

        btn.insertAdjacentElement('afterend', form);
        input.focus();
        input.select();
        activeInlineEdit = { form, btn };
        return form;
      };

      document.addEventListener('click', (evt) => {
        const shareLabelBtn = evt.target.closest('[data-edit-share-label]');
        if (shareLabelBtn) {
          openShareLabelEditor(shareLabelBtn);
          return;
        }
        if (!currentCanEdit) return;
        const nameBtn = evt.target.closest('[data-edit-name]');
        if (nameBtn) {
          createInlineEditor({
            btn: nameBtn,
            type: 'name',
            placeholder: 'e.g. Breakfast',
          });
          return;
        }
        const amountBtn = evt.target.closest('[data-edit-amount]');
        if (amountBtn) {
          createInlineEditor({
            btn: amountBtn,
            type: 'amount',
            placeholder: 'e.g. 250, -120',
          });
        }
        const weightTrigger = evt.target.closest('[data-weight-value]');
        if (weightTrigger) {
          openWeightEditor(weightTrigger);
        }
      });

      attachDotHandlers();

      // Calorie input validation for submit button
      const logForm = document.querySelector('[data-log-form]');
      const calorieInput = logForm?.querySelector('input[name="amount"]');
      const submitBtn = logForm?.querySelector('[data-submit-btn]');

      const isValidCalorieInput = (value) => {
        if (!value || !value.trim()) return false;
        const trimmed = value.trim();
        // Allow: numbers with math operators (+, -, *, /) and parentheses
        // Only allow safe characters to prevent code injection
        if (!/^[\d+\-*/() ]+$/.test(trimmed)) return false;
        // Must contain at least one digit
        if (!/\d/.test(trimmed)) return false;
        try {
          const result = Function('"use strict"; return (' + trimmed + ')')();
          return typeof result === 'number' && isFinite(result);
        } catch {
          return false;
        }
      };

      const updateSubmitState = () => {
        if (!submitBtn || !calorieInput) return;
        submitBtn.disabled = !isValidCalorieInput(calorieInput.value);
      };

      if (calorieInput) {
        // Filter input to only allow numbers and math operators
        const validCalorieChars = /^[\d+\-*/() ]+$/;
        calorieInput.addEventListener('beforeinput', (e) => {
          if (e.inputType === 'insertText' && e.data) {
            // Allow: digits, +, -, *, /, (, ), spaces
            if (!validCalorieChars.test(e.data)) {
              e.preventDefault();
            }
          }
        });

        // Also filter on paste
        calorieInput.addEventListener('paste', (e) => {
          const paste = (e.clipboardData || window.clipboardData).getData('text');
          if (!validCalorieChars.test(paste)) {
            e.preventDefault();
            // Insert only valid characters from paste
            const filtered = paste.replace(/[^\d+\-*/() ]/g, '');
            if (filtered) {
              document.execCommand('insertText', false, filtered);
            }
          }
        });

        calorieInput.addEventListener('input', updateSubmitState);
        updateSubmitState();
      }

      renderEntries(initialEntries, true);
      setActiveDay(currentUserId, currentDate, currentLabel, true, todayStr);
      startEntryEvents();

      const initialDay = todayStr;
      setInterval(() => {
        const today = formatDateTz(new Date());
        if (today && today !== initialDay) {
          window.location.reload();
        }
      }, 60_000);
    })();
  </script>

  <script>
    // Handle disabled AI button clicks
    (() => {
      const trigger = document.querySelector('[data-ai-photo-trigger]');
      if (!trigger) return;

      <% if (!hasAiEnabled) { %>
      trigger.addEventListener('click', (e) => {
        if (trigger.disabled) {
          e.preventDefault();
          e.stopPropagation();
          alert('AI calorie estimation is not configured by the server admin.');
        }
      });
      <% } %>
    })();
  </script>

  <% if (hasAiEnabled) { %>
  <script>
    // AI Photo Estimation
    (() => {
      const trigger = document.querySelector('[data-ai-photo-trigger]');
      if (!trigger) return;

      const calorieInput = document.querySelector('[data-calorie-input]');
      const nameInput = document.querySelector('input[name="entry_name"]');
      const usageBadge = document.querySelector('.ai-usage-badge');

      const updateUsageBadge = (remaining) => {
        if (!usageBadge) return;
        usageBadge.textContent = remaining;
        usageBadge.classList.toggle('exhausted', remaining === 0);
        if (remaining === 0) {
          trigger.classList.add('disabled');
          trigger.disabled = true;
        }
      };

      const decrementUsage = () => {
        if (!usageBadge) return;
        const current = parseInt(usageBadge.textContent, 10);
        if (!isNaN(current) && current > 0) {
          updateUsageBadge(current - 1);
        }
      };

      let modal = null;
      let videoStream = null;
      let currentImage = null;

      const createModal = () => {
        const overlay = document.createElement('div');
        overlay.className = 'ai-modal-overlay';
        overlay.innerHTML = `
          <div class="ai-modal ai-modal-minimal">
            <div class="ai-modal-body">
              <div class="ai-camera-fallback" data-ai-fallback style="display: none;">
                <button type="button" class="ai-fallback-close" data-ai-close>
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                  </svg>
                </button>
                <p class="muted">Could not access camera</p>
                <label class="ghost" style="display: inline-flex; align-items: center; justify-content: center; cursor: pointer;">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                  Upload photo instead
                  <input type="file" accept="image/*" data-ai-upload-fallback style="display: none;">
                </label>
              </div>
              <div class="ai-preview-container" data-ai-preview style="display: none;"></div>
              <div class="ai-context" data-ai-context style="display: none;">
                <label class="field">
                  <span>Add context (optional)</span>
                  <input type="text" data-ai-context-input placeholder="e.g. large portion, 200g chicken, homemade...">
                </label>
                <button type="button" class="primary full" data-ai-analyze>Analyze photo</button>
                <p class="ai-disclaimer muted small">Powered by <%= aiProviderName === 'claude' ? 'Claude' : aiProviderName === 'ollama' ? 'Ollama' : 'OpenAI' %>. Estimates may not be accurate.</p>
              </div>
              <div class="ai-loading" data-ai-loading style="display: none;">
                <div class="ai-loading-spinner"></div>
                <p class="muted">Analyzing with <%= aiProviderName === 'claude' ? 'Claude' : aiProviderName === 'ollama' ? 'Ollama' : 'OpenAI' %>...</p>
                <button type="button" class="ghost danger" data-ai-abort>Cancel</button>
              </div>
              <div class="ai-result" data-ai-result style="display: none;">
                <div class="ai-result-calories" data-ai-calories></div>
                <div class="ai-result-food" data-ai-food></div>
                <div class="ai-result-confidence" data-ai-confidence></div>
                <div class="ai-result-actions">
                  <button type="button" class="primary" data-ai-add>Add entry</button>
                  <button type="button" class="ghost" data-ai-use>Edit first</button>
                  <button type="button" class="ghost" data-ai-retry>Retry</button>
                </div>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(overlay);
        return overlay;
      };

      const stopCamera = () => {
        if (videoStream) {
          videoStream.getTracks().forEach(track => track.stop());
          videoStream = null;
        }
      };

      const closeModal = () => {
        if (!modal) return;
        stopCamera();
        modal.classList.remove('active');
        setTimeout(() => {
          modal.remove();
          modal = null;
        }, 200);
      };

      const showPreview = (imageSrc, showCapture = false) => {
        const container = modal.querySelector('[data-ai-preview]');
        container.innerHTML = showCapture
          ? `<video class="ai-video-preview" autoplay playsinline data-ai-video></video>
             <label class="ai-upload-alt" data-ai-upload-label>
               <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                 <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                 <polyline points="17 8 12 3 7 8"/>
                 <line x1="12" y1="3" x2="12" y2="15"/>
               </svg>
               <input type="file" accept="image/*" data-ai-upload style="display: none;">
             </label>
             <button type="button" class="ai-capture-btn" data-ai-capture></button>
             <button type="button" class="ai-close-alt" data-ai-close>
               <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                 <line x1="18" y1="6" x2="6" y2="18"/>
                 <line x1="6" y1="6" x2="18" y2="18"/>
               </svg>
             </button>`
          : `<img class="ai-preview-img" src="${imageSrc}" alt="Food preview">`;
        container.style.display = 'block';
        modal.querySelector('[data-ai-fallback]').style.display = 'none';
        modal.querySelector('[data-ai-context]').style.display = showCapture ? 'none' : 'block';
        modal.querySelector('[data-ai-loading]').style.display = 'none';
        modal.querySelector('[data-ai-result]').style.display = 'none';
        if (!showCapture) currentImage = imageSrc;
      };

      const showLoading = () => {
        modal.querySelector('[data-ai-preview]').style.display = 'none';
        modal.querySelector('[data-ai-fallback]').style.display = 'none';
        modal.querySelector('[data-ai-context]').style.display = 'none';
        modal.querySelector('[data-ai-loading]').style.display = 'flex';
        modal.querySelector('[data-ai-result]').style.display = 'none';
      };

      const showResult = (data) => {
        modal.querySelector('[data-ai-preview]').style.display = 'none';
        modal.querySelector('[data-ai-actions]').style.display = 'none';
        modal.querySelector('[data-ai-loading]').style.display = 'none';
        modal.querySelector('[data-ai-result]').style.display = 'block';
        modal.querySelector('[data-ai-calories]').textContent = `${data.calories} kcal`;
        modal.querySelector('[data-ai-food]').textContent = data.food;
        modal.querySelector('[data-ai-confidence]').textContent = `Confidence: ${data.confidence}`;
      };

      const showError = (message) => {
        alert(message || 'Could not analyze the image. Please try again.');
        closeModal();
      };

      let currentAbortController = null;

      const analyzeImage = async (base64Image, context = '') => {
        showLoading();

        // Create abort controller for this request
        currentAbortController = new AbortController();

        try {
          const res = await fetch('/api/ai/estimate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ image: base64Image, context }),
            signal: currentAbortController.signal,
          });
          const data = await res.json();
          if (!data.ok) {
            // Handle rate limit response
            if (data.limitReached) {
              updateUsageBadge(0);
            }
            throw new Error(data.error || 'Analysis failed');
          }
          // Decrement usage badge after successful request
          decrementUsage();
          // Auto-fill form fields and close modal
          if (calorieInput) calorieInput.value = data.calories;
          if (nameInput && data.food) nameInput.value = data.food;
          closeModal();
          if (calorieInput) calorieInput.dispatchEvent(new Event('input'));
        } catch (err) {
          if (err.name === 'AbortError') {
            console.log('AI analysis cancelled');
            closeModal();
            return;
          }
          console.error('AI analysis failed', err);
          showError(err.message);
        } finally {
          currentAbortController = null;
        }
      };

      const startCamera = async () => {
        try {
          videoStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' },
            audio: false,
          });
          showPreview('', true);
          const video = modal.querySelector('[data-ai-video]');
          video.srcObject = videoStream;
        } catch (err) {
          console.error('Camera access failed', err);
          // Show fallback upload option
          modal.querySelector('[data-ai-fallback]').style.display = 'flex';
        }
      };

      // Resize image to max 512px (saves API costs)
      const resizeImage = (source, maxSize = 512) => {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          let width, height;

          if (source instanceof HTMLVideoElement) {
            width = source.videoWidth;
            height = source.videoHeight;
          } else {
            width = source.width;
            height = source.height;
          }

          // Calculate new dimensions
          if (width > height) {
            if (width > maxSize) {
              height = Math.round(height * maxSize / width);
              width = maxSize;
            }
          } else {
            if (height > maxSize) {
              width = Math.round(width * maxSize / height);
              height = maxSize;
            }
          }

          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(source, 0, 0, width, height);
          resolve(canvas.toDataURL('image/jpeg', 0.8));
        });
      };

      const capturePhoto = async () => {
        const video = modal.querySelector('[data-ai-video]');
        if (!video || video.readyState < 2) return; // Ensure video is ready
        // Capture frame BEFORE stopping camera
        const base64 = await resizeImage(video);
        stopCamera();
        showPreview(base64);
      };

      const handleFileUpload = (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        const img = new Image();
        img.onload = async () => {
          const base64 = await resizeImage(img);
          showPreview(base64);
        };
        img.src = URL.createObjectURL(file);
      };

      const resetModal = () => {
        currentImage = null;
        modal.querySelector('[data-ai-preview]').style.display = 'none';
        modal.querySelector('[data-ai-fallback]').style.display = 'none';
        modal.querySelector('[data-ai-context]').style.display = 'none';
        modal.querySelector('[data-ai-context-input]').value = '';
        modal.querySelector('[data-ai-loading]').style.display = 'none';
        modal.querySelector('[data-ai-result]').style.display = 'none';
        // Restart camera
        startCamera();
      };

      trigger.addEventListener('click', () => {
        modal = createModal();
        requestAnimationFrame(() => modal.classList.add('active'));

        // Start camera immediately
        startCamera();

        modal.addEventListener('click', async (e) => {
          if (e.target === modal) closeModal();
          if (e.target.closest('[data-ai-close]')) {
            e.preventDefault();
            e.stopPropagation();
            closeModal();
            return;
          }
          if (e.target.closest('[data-ai-capture]')) capturePhoto();
          if (e.target.closest('[data-ai-retry]')) resetModal();
          if (e.target.closest('[data-ai-analyze]')) {
            const context = modal.querySelector('[data-ai-context-input]').value.trim();
            if (currentImage) analyzeImage(currentImage, context);
          }
          if (e.target.closest('[data-ai-abort]')) {
            if (currentAbortController) {
              currentAbortController.abort();
              currentAbortController = null;
            }
          }
          if (e.target.closest('[data-ai-add]')) {
            const calories = modal.querySelector('[data-ai-calories]').textContent.replace(/[^\d]/g, '');
            const food = modal.querySelector('[data-ai-food]').textContent;
            const dateInput = document.querySelector('[data-date-input]');
            const entryDate = dateInput ? dateInput.value : new Date().toISOString().slice(0, 10);

            try {
              const res = await fetch('/entries', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json'
                },
                body: JSON.stringify({
                  amount: calories,
                  entry_name: food,
                  entry_date: entryDate
                }),
              });
              const data = await res.json();
              if (data.ok) {
                closeModal();
                window.location.reload();
              } else {
                alert(data.error || 'Failed to add entry');
              }
            } catch (err) {
              console.error('Failed to add entry', err);
              alert('Failed to add entry');
            }
          }
          if (e.target.closest('[data-ai-use]')) {
            const calories = modal.querySelector('[data-ai-calories]').textContent.replace(/[^\d]/g, '');
            const food = modal.querySelector('[data-ai-food]').textContent;
            if (calorieInput) calorieInput.value = calories;
            if (nameInput && food) nameInput.value = food;
            closeModal();
            if (calorieInput) calorieInput.dispatchEvent(new Event('input'));
          }
        });

        // Handle file uploads from both camera view and fallback
        modal.addEventListener('change', (e) => {
          if (e.target.matches('[data-ai-upload], [data-ai-upload-fallback]')) {
            const file = e.target.files[0];
            if (file) {
              stopCamera();
              handleFileUpload(file);
            }
          }
        });
      });
    })();
  </script>
  <% } %>
<%- include('partials/footer') %>
